#+TITLE: Emacs Configuration file
#+AUTHOR: Peng Li
#+EMAIL: seudut@gmail.com

* Introduction

Most config are just copied from [[https://github.com/howardabrams/dot-files][howardabrams]]'s and [[https://github.com/abo-abo/oremacs][abo-abo's]] dotfiles

* Basic Settings
** Setting loading Path
Set system PATH and emacs exec path
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setenv "PATH" (concat (getenv "PATH")
                         ":" "/usr/local/bin"
                         ":" "/Library/TeX/texbin"))
  (setq exec-path (append exec-path '("/usr/local/bin")))
  (setq exec-path (append exec-path '("/Library/TeX/texbin/")))
#+END_SRC

Set the emacs load path
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (add-to-list 'load-path "~/.emacs.d/elisp")
#+END_SRC

** Package Initialization
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (require 'package)

  (setq package-archives '(("mepla" . "http://melpa.milkbox.net/packages/")
                           ("gnu" . "http://elpa.gnu.org/packages/")
                           ("org" . "http://orgmode.org/elpa/")))

  (package-initialize)
#+END_SRC       

** General Setting
*** scroll bar, tool-bar and menu-bar
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (scroll-bar-mode 0)
  (tool-bar-mode 0)
  (menu-bar-mode 1)

  ;; (setq debug-on-error t)
  (setq inhibit-startup-message t)

  (defalias 'yes-or-no-p 'y-or-n-p)
  (show-paren-mode 1)
  ;; don't backupf
  (setq make-backup-files nil)

  ;;supress the redefined warning at startup
  (setq ad-redefinition-action 'accept)
#+END_SRC

*** Custom file 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent 
  (setq custom-file "~/.emacs.d/custom.el")
  (if (file-exists-p custom-file)
      (load custom-file))
#+END_SRC

*** Switch the focus to help window when it appears
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq help-window-select t)
#+END_SRC

*** Set default window size
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq initial-frame-alist
        '((width . 120)
          (height . 50)))

  ;; (setq-default indicate-empty-lines t)
#+END_SRC

*** Stop auto save
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq auto-save-default nil)

  ;; restore last session
  ;; (desktop-save-mode t)
#+END_SRC

*** temp folder
Make a temp directory for all cache/history files
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defconst sd-temp-directory
    (file-name-as-directory "~/.emacs.d/temp"))

  (unless (file-exists-p sd-temp-directory)
    (mkdir sd-temp-directory))
#+END_SRC

*** Save minibuffer history
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq savehist-file (concat sd-temp-directory "history"))
  (setq history-length 1000)
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (savehist-mode 1)

  ;; set temp file path for recentf and auto-save
  (setq recentf-save-file (concat sd-temp-directory "recentf"))
  (setq auto-save-list-file-prefix (concat sd-temp-directory "auto-save-list/.saves-"))
#+END_SRC

*** Max file size
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq large-file-warning-threshold nil)
#+END_SRC

* Package Management Tools
** Use-package
Using [[https://github.com/jwiegley/use-package][use-package]] to manage emacs packages
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)
#+END_SRC

** El-get
[[https://github.com/dimitri/el-get][El-get]] is package management tool, whicl allows to install external elisp package from any git repository not in mepla. 
Check out [[http://tapoueh.org/emacs/el-get.html][el-get]].
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package el-get
    :ensure t
    :init
    (add-to-list 'load-path "~/.emacs.d/el-get"))
#+END_SRC

** paradox
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package paradox
    :ensure t)
#+END_SRC

* Mac Specific
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (defconst *is-a-mac* (eq system-type 'darwin))
  ;; (setq mouse-wheel-scroll-amount '(1
  ;;                                   ((shift) . 5)
  ;;                                   ((control))))


  ;; (setq-default indicate-empty-lines t)
#+END_SRC

* Color and Fonts Settings
** highlight current line
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (global-hl-line-mode)
  ;; don't want high light current line in eshell/term mode
  (add-hook 'prog-mode-hook 'hl-line-mode)
  (add-hook 'text-mode-hook 'hl-line-mode)
  (add-hook 'dired-mode-hook 'hl-line-mode)
#+END_SRC

** Smart Comments

[[https://github.com/paldepind/smart-comment][smart-comments]]

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package smart-comment
    :ensure t
    :bind ("M-;" . smart-conmment))

#+END_SRC

** Font Setting
syntax highlighting
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-font-lock-mode 1)
#+END_SRC

[[https://github.com/i-tu/Hasklig][Hasklig]] and Source Code Pro, defined fonts family
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (if window-system
      (defvar sd/fixed-font-family
        (cond ((x-list-fonts "Hasklig")         "Hasklig")
              ((x-list-fonts "Source Code Pro") "Source Code Pro:weight")
              ((x-list-fonts "Anonymous Pro")   "Anonymous Pro")
              ((x-list-fonts "M+ 1mn")          "M+ 1mn"))
        "The fixed width font based on what is installed, `nil' if not defined."))
#+END_SRC

Setting the fonts 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (if window-system
      (when sd/fixed-font-family
        (set-frame-font sd/fixed-font-family)
        (set-face-attribute 'default nil :font sd/fixed-font-family :height 130)
        (set-face-font 'default sd/fixed-font-family)))
#+END_SRC

** Color Theme

Loading theme should be after all required loaded, refere [[https://github.com/jwiegley/use-package][:defer]] in =use-package=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq vc-follow-symlinks t)

  (use-package color-theme
    :ensure t
    :init (require 'color-theme)
    :config (use-package color-theme-sanityinc-tomorrow
              :ensure t
              :no-require t
              :config
              ;; (load-theme 'sanityinc-tomorrow-bright t)
              (load-theme 'molokai t)
              ))

  ;(eval-after-load 'color-theme
  ;  (load-theme 'sanityinc-tomorrow-bright t))

#+END_SRC

Change the Org-mode colors 

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (defun org-src-color-blocks-light ()
    "Colors the block headers and footers to make them stand out more for lighter themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line
      ((t (:underline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))
     '(org-block-background
       ((t (:background "#FFFFEA"))))
     '(org-block
       ((t (:background "#FFFFEA"))))
     '(org-block-end-line
       ((t (:overline "#A7A6AA" :foreground "#008ED1" :background "#EAEAFF"))))

     '(mode-line-buffer-id ((t (:foreground "#005000" :bold t))))
     '(which-func ((t (:foreground "#008000"))))))

  (defun org-src-color-blocks-dark ()
    "Colors the block headers and footers to make them stand out more for dark themes"
    (interactive)
    (custom-set-faces
     '(org-block-begin-line
       ((t (:foreground "#008ED1" :background "#002E41"))))
     '(org-block-background
       ((t (:background "#000000"))))
     '(org-block
       ((t (:background "#000000"))))
     '(org-block-end-line
       ((t (:foreground "#008ED1" :background "#002E41"))))

     '(mode-line-buffer-id ((t (:foreground "black" :bold t))))
     '(which-func ((t (:foreground "green"))))))

  (org-src-color-blocks-dark)

#+END_SRC

improve color for org-mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (deftheme ha/org-theme "Sub-theme to beautify org mode")

  (if window-system
      (defvar sd/variable-font-tuple
        (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
              ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
              ((x-list-fonts "Verdana")         '(:font "Verdana"))
              ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
              (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro.")))
        "My variable width font available to org-mode files and whatnot."))

  (defun sd/org-color ()
    (let* ((sd/fixed-font-tuple (list :font sd/fixed-font-family))
           (base-font-color     (face-foreground 'default nil 'default))
           (background-color    (face-background 'default nil 'default))
           (primary-color       (face-foreground 'mode-line nil))
           (secondary-color     (face-background 'secondary-selection nil 'region))
           (base-height         (face-attribute 'default :height))
           (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
      (custom-theme-set-faces 'ha/org-theme
                              `(org-agenda-structure ((t (:inherit default :height 2.0 :underline nil))))
                              `(org-verbatim ((t (:inherit 'fixed-pitched :foreground "#aef"))))
                              `(org-table ((t (:inherit 'fixed-pitched))))
                              `(org-block ((t (:inherit 'fixed-pitched))))
                              `(org-block-background ((t (:inherit 'fixed-pitched))))
                              `(org-block-begin-line ((t (:inherit 'fixed-pitched))))
                              `(org-block-end-line ((t (:inherit 'fixed-pitched))))
                              `(org-level-8 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-7 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-6 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-5 ((t (,@headline ,@sd/variable-font-tuple))))
                              `(org-level-4 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.1 base-height))))))
                              `(org-level-3 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.25 base-height))))))
                              `(org-level-2 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.5 base-height))))))
                              `(org-level-1 ((t (,@headline ,@sd/variable-font-tuple
                                                            :height ,(round (* 1.75 base-height))))))
                              `(org-document-title ((t (,@headline ,@sd/variable-font-tuple :height 1.5 :underline nil)))))))


#+END_SRC

** Rainbow-delimiter

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

#+END_SRC

** page-break-lines
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package page-break-lines
    :ensure t
    :config
    (global-page-break-lines-mode)
    ;; (turn-on-page-break-lines-mode)
    )
#+END_SRC

** rainbow-mode

Enable rainbow mode in emacs lisp mode

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package rainbow-mode
    :ensure t
  ;  :init
  ;  (add-hook emacs-lisp-mode-hook 'rainbow-mode)
    )

#+END_SRC

** cusor color
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (set-cursor-color 'red)
#+END_SRC

* Mode-line
** clean mode line
clean mode line, Refer to [[https://www.masteringemacs.org/article/hiding-replacing-modeline-strings][Marstering Emacs]], some greek character see [[http://xahlee.info/math/math_unicode_greek.html][math_unicode_greek]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defvar mode-line-cleaner-alist
    `((auto-complete-mode . " Œ±")
      (paredit-mode . " œÄ")
      (eldoc-mode . "")
      (abbrev-mode . "")
      (projectile-mode . "")
      (ivy-mode . "")
      (undo-tree-mode . "")
      ;; default is WK
      (which-key-mode . "")
      ;; default is SP
      (smartparens-mode . "")
      ;; default is LR
      (linum-relative-mode . "")
      ;; default is ARev
      (auto-revert-mode . "")
      ;; default is Ind
      (org-indent-mode . "")
      ;; default is  Fly
      (flyspell-mode . "")
      (irony-mode . "")
      (page-break-lines-mode . "")
      (yas-minor-mode . "y")
      ;; Major modes
      (lisp-interaction-mode . "Œª")
      (hi-lock-mode . "")
      (python-mode . "Py")
      (emacs-lisp-mode . "EL")
      (eshell-mode . "ùûî")
      (dired-mode . "ùûì")
      (ibuffer-mode . "ùûë")
      (org-mode . "ùûû")
      (nxhtml-mode . "nx"))
    "Alist for `clean-mode-line'.

  When you add a new element to the alist, keep in mind that you
  must pass the correct minor/major mode symbol and a string you
  want to use in the modeline *in lieu of* the original.")


  (defun clean-mode-line ()
    (interactive)
    (loop for cleaner in mode-line-cleaner-alist
          do (let* ((mode (car cleaner))
                   (mode-str (cdr cleaner))
                   (old-mode-str (cdr (assq mode minor-mode-alist))))
               (when old-mode-str
                   (setcar old-mode-str mode-str))
                 ;; major mode
               (when (eq mode major-mode)
                 (setq mode-name mode-str)))))


  (add-hook 'after-change-major-mode-hook 'clean-mode-line)
#+END_SRC

** Powerline mode
Install powerline mode [[https://github.com/milkypostman/powerline][powerline]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package powerline
    :ensure t
    :config
    ;; (powerline-center-theme)
    )

  ;; (use-package smart-mode-line
  ;;   :ensure t)
  ;; (use-package smart-mode-line-powerline-theme
  ;;   :ensure t)
#+END_SRC

Revised powerline-center-theme
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/powerline-simpler-vc (s)
    (if s
        (replace-regexp-in-string "Git[:-]" "" s)
      s))

  (defface sd/powerline-active1 '((t (:background "yellow" :foreground "black" :inherit mode-line)))
    "My Powerline face 1 based on powerline-active1."
    :group 'powerline)

  (defface sd/buffer-modified-active1 '((t (:background "red" :foreground "black" :inherit mode-line)))
    "My Powerline face 1 based on powerline-active1."
    :group 'powerline)

  (defface sd/buffer-view-active1 '((t (:background "green" :foreground "black" :inherit mode-line)))
    "My Powerline face 1 based on powerline-active1."
    :group 'powerline)

  (defface sd/mode-line-buffer-id
    '((t (:background "yellow" :foreground "black" :inherit mode-line-buffer-id)))
    "My powerline mode-line face, based on mode-line-buffer-id"
    :group 'powerline)

  ;; Don't show buffer modified for scratch and eshell mode
  (defun sd/buffer-is-eshel-or-scratch ()
    "Dot not show modified indicator for buffers"
    (interactive)
    (unless (or (string-match "*scratch*" (buffer-name))
                (equal major-mode 'eshell-mode))
      t))

  (defun sd/powerline-center-theme_revised ()
    "Setup a mode-line with major and minor modes centered."
    (interactive)
    (setq-default mode-line-format
                  '("%e"
                    (:eval
                     (let* ((active (powerline-selected-window-active))
                            (mode-line-buffer-id (if active 'sd/mode-line-buffer-id 'mode-line-buffer-id-inactive))
                            (mode-line (if active 'mode-line 'mode-line-inactive))
                            (my-face1 (if active 'sd/powerline-active1 'powerline-inactive1))
                            (my-face-buffer-modified (if (and (sd/buffer-is-eshel-or-scratch) (buffer-modified-p) (not buffer-read-only)) 
                                                         'sd/buffer-modified-active1
                                                       (if buffer-read-only 'sd/buffer-view-active1
                                                         my-face1)))
                            (face1 (if active 'powerline-active1 'powerline-inactive1))
                            (face2 (if active 'powerline-active2 'powerline-inactive2))
                            (separator-left (intern (format "powerline-%s-%s"
                                                            (powerline-current-separator)
                                                            (car powerline-default-separator-dir))))
                            (separator-right (intern (format "powerline-%s-%s"
                                                             (powerline-current-separator)
                                                             (cdr powerline-default-separator-dir))))
                            (lhs (list (powerline-raw "%* " my-face-buffer-modified 'l)
                                       ;; (powerline-buffer-size mode-line 'l)
                                       (powerline-buffer-id mode-line-buffer-id 'l)
                                       (powerline-raw " " my-face1)
                                       (funcall separator-left my-face1 face1)
                                       (powerline-narrow face1 'l)
                                       ;; (powerline-vc face1)
                                       (sd/powerline-simpler-vc (powerline-vc face1))))
                            (rhs (list (powerline-raw global-mode-string face1 'r)
                                       (powerline-raw "%4l" face1 'r)
                                       (powerline-raw ":" face1)     
                                       (powerline-raw "%3c" face1 'r)
                                       (funcall separator-right face1 my-face1)
                                       ;; (powerline-raw " " my-face1)
                                       (powerline-raw (format-time-string " %I:%M %p  ") my-face1 'r)
                                       ;; (powerline-raw "%6p" my-face1 'r)
                                       ;; (powerline-hud my-face1 face1 )
                                       ))
                            (center (list (powerline-raw " " face1)
                                          (funcall separator-left face1 face2)
                                          (when (and (boundp 'erc-track-minor-mode) erc-track-minor-mode)
                                            (powerline-raw erc-modified-channels-object face2 'l))
                                          (powerline-major-mode face2 'l)
                                          (powerline-process face2)
                                          (powerline-raw " :" face2)
                                          (powerline-minor-modes face2 'l)
                                          (powerline-raw " " face2)
                                          (funcall separator-right face2 face1))))
                       (concat (powerline-render lhs)
                               (powerline-fill-center face1 (/ (powerline-width center) 2.0))
                               (powerline-render center)
                               (powerline-fill face1 (powerline-width rhs))
                               (powerline-render rhs)))))))

  (sd/powerline-center-theme_revised)
#+END_SRC

Fix the issue in mode line when showing triangle 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq ns-use-srgb-colorspace nil)
#+END_SRC

set height in mode line
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (set-variable 'powerline-height 14)
  (set-variable 'powerline-text-scale-factor (/ (float 100) 140))
  ;; (custom-set-variables
  ;;  '(powerline-height 14)
  ;;  '(powerline-text-scale-factor (/ (float 100) 140)))
  ;; 100/140;0.8
  (set-face-attribute 'mode-line nil :height 100)
#+END_SRC

* IDO & SMEX
** IDO
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ido
    :ensure t
    :init (setq ido-enable-flex-matching nil
                ido-ignore-extensions t
                ido-use-virtual-buffers t
                ido-everywhere t)
    (setq ido-save-directory-list-file (concat sd-temp-directory "ido.last"))
    :config
    (ido-mode 1)
    (ido-everywhere 1)
    (add-to-list 'completion-ignored-extensions ".pyc"))

  (icomplete-mode t)
#+END_SRC

** FLX
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package flx-ido
    :ensure t
    :init (setq ido-enable-flex-matching nil
                ido-use-faces nil)
    :config (flx-ido-mode nil))
#+END_SRC

** IDO-vertically
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ido-vertical-mode
    :ensure t
    :init
    (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
    :config
    (ido-vertical-mode 1))
#+END_SRC

** SMEX
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package smex
    :ensure t
    :init
    (setq smex-save-file (concat sd-temp-directory "smex-items"))
    (smex-initialize)
    :bind
    ("M-x" . smex)
    ("M-X" . smex-major-mode-commands))
#+END_SRC

** Ido-ubiquitous
Use [[https://github.com/DarwinAwardWinner/ido-ubiquitous][ido-ubiquitous]] for ido everywhere. It makes =describe-function= can also use ido
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ido-ubiquitous
    :ensure t
    :init
    (setq magit-completing-read-function 'magit-ido-completing-read)
    (setq gnus-completing-read-function 'gnus-ido-completing-read)
    :config
    (ido-ubiquitous-mode 1))
#+END_SRC

** Ido-exit-target
[[https://github.com/waymondo/ido-exit-target][ido-exit-target]] let you open file/buffer on =other-windows= when call =ido-switch-buffer=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ido-exit-target
    :ensure t
    :init
    (mapcar #'(lambda (map)
              (define-key map (kbd "C-j") #'ido-exit-target-other-window)
              (define-key map (kbd "C-k") #'ido-exit-target-split-window-below))
            (list ido-buffer-completion-map
                  ;; ido-common-completion-map
                  ido-file-completion-map
                  ido-file-dir-completion-map)))
#+END_SRC

** Counsel
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package counsel
    :ensure t
    :defer t
    :init
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-h f") 'counsel-describe-function)
    (global-set-key (kbd "C-h v") 'counsel-describe-variable)
    ;; (set-face-attribute 'ivy-current-match nil :background "Orange" :foreground "black")
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    (global-set-key (kbd "C-c C-r") 'ivy-resume))



  ;; (global-set-key "\C-s" 'swiper)
  ;; (global-set-key (kbd "<f6>") 'ivy-resume)
  ;; ;; (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  ;; (global-set-key (kbd "<f1> l") 'counsel-load-library)
  ;; (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  ;; (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
  ;; (global-set-key (kbd "C-c g") 'counsel-git)
  ;; (global-set-key (kbd "C-c j") 'counsel-git-grep)
  ;; (global-set-key (kbd "C-c k") 'counsel-ag)
  ;; (global-set-key (kbd "C-x l") 'counsel-locate)
  ;; (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)

  ;; (set-face-attribute
  ;;  'ivy-current-match nil
  ;;  :background "Orange"
  ;;  :foreground "black")

  ;; ivy-resume
  ;; (define-key swiper-map (kbd "M-%") 'swiper-aa-replace)
#+END_SRC

** helm
let helm windows split inside current window
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (with-eval-after-load 'helm
    (setq helm-split-window-in-side-p t))
#+END_SRC

* Org-mode Settings
** Org-mode Basic setting
Always indents header, and hide header leading starts so that no need type =#+STATUP: indent= 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package org
    :ensure t
    :init
    (setq org-startup-indented t)
    (setq org-hide-leading-starts t)
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-confirm-babel-evaluate nil)
    (setq org-use-speed-commands t)
    (setq org-completion-use-ido t)
    (setq org-startup-with-inline-images t))

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (C . t)
     (perl . t)
     (calc . t)
     (latex . t)
     (java . t)
     (ruby . t)
     (lua . t)
     (lisp . t)
     (scheme . t)
     (sh . t)
     (sqlite . t)
     (js . t)
     (gnuplot . t)
     (ditaa . t)))

  ;; use current window for org source buffer editting
  (setq org-src-window-setup 'current-window )

  (define-key org-mode-map (kbd "C-'") nil)
  ;; C-M-i is mapped to imenu globally
  (define-key org-mode-map (kbd "C-M-i") nil)

  ;; set the ditta.jar path
  (setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")
  (unless 
      (file-exists-p org-ditaa-jar-path)
    (error "seudut: ditaa.jar not found at %s " org-ditaa-jar-path))

  ;; Lua support
  (use-package ob-lua
    :ensure t)
#+END_SRC

** Org-bullets
use [[https://github.com/sabof/org-bullets][org-bullets]] package to show utf-8 charactes
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package org-bullets
    :ensure t
    :init
    (add-hook 'org-mode-hook
              (lambda ()
                (org-bullets-mode t))))

  (setq org-bullets-bullet-list '("‚¶ø" "‚ú™" "‚óâ" "‚óã" "‚ñ∫" "‚óÜ"))

  ;; increase font size when enter org-src-mode
  (add-hook 'org-src-mode-hook (lambda () (text-scale-increase 2)))
#+END_SRC

** Worf Mode
[[https://github.com/abo-abo/worf][worf]] mode is an extension of vi-like binding for org-mode. 
In =worf-mode=, it is mapping =[=, =]= as =worf-backward= and =worf-forward= in global, wich
cause we cannot input =[= and =]=, so here I unset this mappings. And redifined this two to
=M-[= and =M-]=. see this [[https://github.com/abo-abo/worf/issues/19#issuecomment-223756599][issue]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package worf
    :ensure t
    :commands worf-mode
    :init (add-hook 'org-mode-hook 'worf-mode))
#+END_SRC

** Get Things Done
Refer to [[http://doc.norang.ca/org-mode.html][Organize Your Life in Plain Text]]
*** basic setup
standard key binding
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

*** Plain List 
Replace the list bullet =-=, =+=,  with =‚Ä¢=, a litter change based [[https://github.com/howardabrams/dot-files/blob/master/emacs-org.org][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (use-package org-mode
  ;;   :init
  ;;   (font-lock-add-keywords 'org-mode
  ;;    '(("^ *\\([-+]\\) "
  ;;           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "‚Ä¢")))))))
#+END_SRC
 
*** Todo Keywords
refer to [[http://coldnew.github.io/coldnew-emacs/#orgheadline94][fancy todo states]], 
To track TODO state changes, the =!= is to insert a timetamp, =@= is to insert a note with
timestamp for the state change.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
    ;; (setq org-todo-keywords
    ;;        '((sequence "‚òõ TODO(t)" "|" "‚úî DONE(d)")
    ;;          (sequence "‚öë WAITING(w)" "|")
    ;;          (sequence "|" "‚úò CANCELLED(c)")))
  ; (setq org-todo-keyword-faces
  ;        (quote ("TODO" .  (:foreground "red" :weight bold))
  ;               ("NEXT" .  (:foreground "blue" :weight bold))
  ;               ("WAITING" . (:foreground "forest green" :weight bold))
  ;               ("DONE" .  (:foreground "magenta" :weight bold))
  ;               ("CANCELLED" . (:foreground "forest green" :weight bold))))


  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
                ;; (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" ))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ;; ("MEETING" :foreground "forest green" :weight bold)
                ;; ("PHONE" :foreground "forest green" :weight bold)
                )))
#+END_SRC

Fast todo selections

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-use-fast-todo-selection t)
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

TODO state triggers and tags, [[http://doc.norang.ca/org-mode.html][Organize Your Life in Plain Text]]

- Moving a task to =CANCELLED=, adds a =CANCELLED= tag
- Moving a task to =WAITING=, adds a =WAITING= tag
- Moving a task to =HOLD=, add =HOLD= tags
- Moving a task to =DONE=, remove =WAITING=, =HOLD= tag
- Moving a task to =NEXT=, remove all waiting/hold/cancelled tags

This tags are used to filter tasks in agenda views
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+END_SRC

Logging Stuff 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; log time when task done
  ;; (setq org-log-done (quote time))
  ;; save clocking into to LOGBOOK
  (setq org-clock-into-drawer t)
  ;; save state change notes and time stamp into LOGBOOK drawer
  (setq org-log-into-drawer t)
  (setq org-clock-into-drawer "CLOCK")
#+END_SRC

*** Tags
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-tag-alist (quote ((:startgroup)
                              ("@office" . ?e)
                              ("@home" . ?h)
                              (:endgroup)
                              ("WAITING" . ?w)
                              ("HOLD" . ?h)
                              ("CANCELLED" . ?c))))

  ;; Allow setting single tags without the menu
  (setq org-fast-tag-selection-single-key (quote expert))
#+END_SRC

*** Capture - Refile - Archive

Capture lets you quickly store notes with little interruption of your work flow.

**** Capture Templates

When a new taks needs to be added, categorize it as 

All captured file which need next actions are stored in =refile.org=, 
- A new task / note (t) =refile.org=
- A work task in office =office.org=
- A jourenl =diary.org=
- A new habit (h) =refile.org=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-directory "~/org")
  (setq org-default-notes-file "~/org/refile.org")
  (setq sd/org-diary-file "~/org/diary.org")

  (global-set-key (kbd "C-c c") 'org-capture)

  (setq org-capture-templates
        (quote (("t" "Todo" entry (file org-default-notes-file)
                 "* TODO %?\n:LOGBOOK:\n- Added: %U\t\tAt: %a\n:END:")
                ("n" "Note" entry (file org-default-notes-file)
                 "* %? :NOTE:\n:LOGBOOK:\n- Added: %U\t\tAt: %a\n:END:")
                ("j" "Journal" entry (file+datetree sd/org-diary-file)
                 "* %?\n:LOGBOOK:\n:END:" :clock-in t :clock-resume t)
                ("h" "Habit" entry (file org-default-notes-file)
                 "* NEXT %?\n:LOGBOOK:\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:END:\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n "))))
#+END_SRC

**** Refiling Tasks

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-refile-targets (quote (;; (nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))

  (setq org-refile-use-outline-path t)

  (setq org-refile-allow-creating-parent-nodes (quote confirm))
#+END_SRC

*** Agenda Setup
Setting agenda files and the agenda view
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq org-agenda-files (quote ("~/org/gtd.org"
                                 "~/org/work.org")))

  ;; only show today's tasks in agenda view
  (setq org-agenda-span 'day)
  ;; Use current windows for agenda view
  (setq org-agenda-window-setup 'current-window)

  ;; show all feature entries for repeating tasks,
  ;; this is already setting by default
  (setq org-agenda-repeating-timestamp-show-all t)

  ;; Show all agenda dates - even if they are empty
  (setq org-agenda-show-all-dates t)
#+END_SRC

** Export PDF
Install MacTex-basic [[http://www.tug.org/mactex/morepackages.html][MacTex-basic]]  and some tex packages
#+BEGIN_SRC sh 
  wget http://tug.org/cgi-bin/mactex-download/BasicTeX.pkg

  sudo tlmgr update --self

  sudo tlmgr install titlesec framed threeparttable wrapfig multirow enumitem bbding titling tabu mdframed tcolorbox textpos import varwidth needspace tocloft ntheorem environ trimspaces collection-fontsrecommended capt-of
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; ;; allow for export=>beamer by placing

  ;; http://emacs-fu.blogspot.com/2011/04/nice-looking-pdfs-with-org-mode-and.html
  ;; #+LaTeX_CLASS: beamer in org files
  (unless (boundp 'org-export-latex-classes)
    (setq org-export-latex-classes nil))
  (add-to-list 'org-export-latex-classes
    ;; beamer class, for presentations
    '("beamer"
       "\\documentclass[11pt]{beamer}\n
        \\mode<{{{beamermode}}}>\n
        \\usetheme{{{{beamertheme}}}}\n
        \\usecolortheme{{{{beamercolortheme}}}}\n
        \\beamertemplateballitem\n
        \\setbeameroption{show notes}
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{hyperref}\n
        \\usepackage{color}
        \\usepackage{listings}
        \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
    frame=single,
    basicstyle=\\small,
    showspaces=false,showstringspaces=false,
    showtabs=false,
    keywordstyle=\\color{blue}\\bfseries,
    commentstyle=\\color{red},
    }\n
        \\usepackage{verbatim}\n
        \\institute{{{{beamerinstitute}}}}\n          
         \\subject{{{{beamersubject}}}}\n"

       ("\\section{%s}" . "\\section*{%s}")
 
       ("\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}"
         "\\begin{frame}[fragile]\\frametitle{%s}"
         "\\end{frame}")))

    ;; letter class, for formal letters

    (add-to-list 'org-export-latex-classes

    '("letter"
       "\\documentclass[11pt]{letter}\n
        \\usepackage[utf8]{inputenc}\n
        \\usepackage[T1]{fontenc}\n
        \\usepackage{color}"
 
       ("\\section{%s}" . "\\section*{%s}")
       ("\\subsection{%s}" . "\\subsection*{%s}")
       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
       ("\\paragraph{%s}" . "\\paragraph*{%s}")
       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


  (require 'ox-md)
  (require 'ox-beamer)

  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

  (setq TeX-parse-self t)

  (setq TeX-PDF-mode t)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))

#+END_SRC

** Org structure template
extend org-mode's easy templates, refer to [[http://coldnew.github.io/coldnew-emacs/#orgheadline94][Extend org-modes' esay templates]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
    (add-to-list 'org-structure-template-alist
                 '("E" "#+BEGIN_SRC emacs-lisp :tangle yes :results silent\n?\n#+END_SRC"))
    (add-to-list 'org-structure-template-alist
                 '("S" "#+BEGIN_SRC sh :results output replace\n?\n#+END_SRC"))
    (add-to-list 'org-structure-template-alist
                 '("p" "#+BEGIN_SRC plantuml :file uml.png \n?\n#+END_SRC"))
    (add-to-list 'org-structure-template-alist
                 '("P" "#+BEGIN_SRC perl \n?\n#+END_SRC"))
    (add-to-list 'org-structure-template-alist
                 '("f" "#+BEGIN_SRC fundamental :tangle ?\n\n#+END_SRC"))
#+END_SRC

* Magit
[[https://github.com/magit/magit][Magit]] is a very cool git interface on Emacs.
and Defined keys, using vi keybindings, Refer abo-abo's setting [[https://github.com/abo-abo/oremacs/blob/c5cafdcebc88afe9e73cc8bd40c49b70675509c7/modes/ora-nextmagit.el][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package magit
    :ensure t
    :init
    ;; don't ask me to confirm the unsaved change 
    (setq magit-save-repository-buffers nil)
    ;; default is 50
    (setq git-commit-summary-max-length 80)
    :commands magit-status magit-blame
    :config
    (dolist (map (list magit-status-mode-map
                       magit-log-mode-map
                       magit-diff-mode-map
                       magit-staged-section-map))
      (define-key map "j" 'magit-section-forward)
      (define-key map "k" 'magit-section-backward)
      (define-key map "D" 'magit-discard)
      (define-key map "O" 'magit-discard-file)
      (define-key map "n" nil)
      (define-key map "p" nil)
      (define-key map "v" 'recenter-top-bottom)
      (define-key map "i" 'magit-section-toggle)))
#+END_SRC

* Eshell
** Eshell alias
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defalias 'e 'find-file)
  (defalias 'ff 'find-file)
  (defalias 'ee 'find-files)
#+END_SRC

** eshell temp directory
set default eshell history folder
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq eshell-directory-name (concat  sd-temp-directory "eshell"))
#+END_SRC

** Eshell erase buffer
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/eshell-clear-buffer ()
    "Clear eshell buffer"
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))

   (add-hook 'eshell-mode-hook (lambda ()
                                (local-set-key (kbd "C-l") 'sd/eshell-clear-buffer)))
#+END_SRC

** Toggle Eshell
Toggle an eshell in split window below, refer [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][eshell-here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/window-has-eshell ()
    "Check if current windows list has a eshell buffer, and return the window"
    (interactive)
    (let ((ret nil))
      (walk-windows (lambda (window)
                      (if (equal (with-current-buffer (window-buffer window) major-mode)
                                 'eshell-mode)
                          (setq ret window)))
                    nil nil)
      ret))

  (defun sd/toggle-project-eshell ()
    "Toggle a eshell buffer vertically"
    (interactive)
    (if (sd/window-has-eshell)
        (if (equal major-mode 'eshell-mode)
            (progn
              (if (equal (length (window-list)) 1)
                  (mode-line-other-buffer)
                (delete-window)))
          (select-window (sd/window-has-eshell)))
      (progn
        (split-window-vertically (- (/ (window-total-height) 3)))
        (other-window 1)
        (if (projectile-project-p)
            (projectile-run-eshell)
          (eshell))
        ;; (let ((dir default-directory))
        
        ;;   (split-window-vertically (- (/ (window-total-height) 3)))
        ;;   (other-window 1)
        ;;   (unless (and (boundp 'eshell-buffer-name) (get-buffer eshell-buffer-name))
        ;;     (eshell))
        ;;   (switch-to-buffer eshell-buffer-name)
        ;;   (goto-char (point-max))
        ;;   (eshell-kill-input)
        ;;   (insert (format "cd %s" dir))
        ;;   (eshell-send-input))
        )))

  ;; (global-unset-key (kbd "M-`"))
  (global-set-key (kbd "s-e") 'sd/toggle-project-eshell)
#+END_SRC

** exec-path-from-shell
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package exec-path-from-shell
    :ensure t
    :init
    (setq exec-path-from-shell-check-startup-files nil)
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

* Misc Settings
** [[https://github.com/abo-abo/hydra][Hydra]]
*** hydra install
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package hydra
    :ensure t)
  ;; disable new line in minibuffer when hint hydra
  (setq hydra-lv nil)
#+END_SRC

*** Windmove Splitter

Refer [[https://github.com/abo-abo/hydra/blob/master/hydra-examples.el][hydra-example]], to enlarge or shrink the windows splitter

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (defun hydra-move-splitter-left (arg)
    "Move window splitter left."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (shrink-window-horizontally arg)
      (enlarge-window-horizontally arg)))

  (defun hydra-move-splitter-right (arg)
    "Move window splitter right."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'right))
        (enlarge-window-horizontally arg)
      (shrink-window-horizontally arg)))

  (defun hydra-move-splitter-up (arg)
    "Move window splitter up."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (enlarge-window arg)
      (shrink-window arg)))

  (defun hydra-move-splitter-down (arg)
    "Move window splitter down."
    (interactive "p")
    (if (let ((windmove-wrap-around))
          (windmove-find-other-window 'up))
        (shrink-window arg)
      (enlarge-window arg)))

#+END_SRC

*** hydra misc
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defhydra sd/hydra-misc (:color red :columns nil)
    "Misc"
    ("e" eshell "eshell" :exit t)
    ("p" (lambda ()
           (interactive)
           (if (not (eq nil (get-buffer "*Packages*")))
               (switch-to-buffer "*Packages*")
             (package-list-packages)))
     "list-package" :exit t)
    ("g" magit-status "git-status" :exit t)
    ("'" mode-line-other-buffer "last buffer" :exit t)
    ("C-'" mode-line-other-buffer "last buffer" :exit t)
    ("m" man "man" :exit t)
    ("d" dired-jump "dired" :exit t)
    ("b" ibuffer "ibuffer" :exit t)
    ("q" nil "quit")
    ("f" nil "quit"))

  (global-set-key (kbd "C-'") 'sd/hydra-misc/body)
#+END_SRC

*** hydra launcher
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defhydra sd/hydra-launcher (:color blue :columns 2)
    "Launch"
    ("e" emms "emms" :exit t)
    ("q" nil "cancel"))
#+END_SRC

** Line Number

Enable linum mode on programming modes

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (add-hook 'prog-mode-hook 'linum-mode)
  ;; (add-hook 'prog-mode-hook (lambda ()
  ;;                             (setq-default indicate-empty-lines t)))
#+END_SRC

Fix the font size of line number

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (defun fix-linum-size ()
       (interactive)
       (set-face-attribute 'linum nil :height 110))

  (add-hook 'linum-mode-hook 'fix-linum-size)

#+END_SRC

I like [[https://github.com/coldnew/linum-relative][linum-relative]], just like the =set relativenumber= on =vim=

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package linum-relative
    :ensure t
    :init
    (setq linum-relative-current-symbol "")
    :config
    (defun linum-new-mode ()
      "If line numbers aren't displayed, then display them.
  Otherwise, toggle between absolute and relative numbers."
      (interactive)
      (if linum-mode
          (linum-relative-toggle)
        (linum-mode 1)))

    :bind
    ("A-k" . linum-new-mode))

  ;; auto enable linum-new-mode in programming modes
  (add-hook 'prog-mode-hook 'linum-relative-mode)
#+END_SRC

** Save File Position

#+BEGIN_SRC emacs-lisp :tangle yes :results silent

  (require 'saveplace)
  (setq-default save-place t)
  (setq save-place-forget-unreadable-files t)
  (setq save-place-skip-check-regexp "\\`/\\(?:cdrom\\|floppy\\|mnt\\|/[0-9]\\|\\(?:[^@/:]*@\\)?[^@/:]*[^@/:.]:\\)")

#+END_SRC

** Multi-term
define =multi-term= mapping to disable some mapping which is used globally.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package multi-term
    :ensure t)

  (defun sd/term-mode-mapping ()
    (mapcar #'(lambda (map)
              (define-key map (kbd "C-o") nil)
              (define-key map (kbd "C-g") nil))
            (list term-mode-map
                  term-raw-map)))

  (with-eval-after-load 'multi-term
    (sd/term-mode-mapping))
#+END_SRC

** ace-link
[[https://github.com/abo-abo/ace-link][ace-link]] is a package written by [[https://github.com/abo-abo][Oleh Krehel]]. It is convenient to jump to link in help mode, info-mode, etc
Type =o= to go to the link
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ace-link
    :ensure t
    :init
    (ace-link-setup-default))
#+END_SRC

** Smart Parens
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package smartparens
    :ensure t
    :config
    (progn
      (require 'smartparens-config)
      (add-hook 'prog-mode-hook 'smartparens-mode)))
#+END_SRC

** Ace-Windows
[[https://github.com/abo-abo/ace-window][ace-window]] 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ace-window
    :ensure t
    :defer t
                                          ;  :init
                                          ;  (global-set-key (kbd "M-o") 'ace-window)
    :config
    (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l)))
#+END_SRC

** Which key
[[https://github.com/justbur/emacs-which-key][which-key]] show the key bindings 
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC

** View only for some directory
When see function by =C-h f=, and visit the source code, I would like the buffer is read only. See [[http://emacs.stackexchange.com/questions/3676/how-to-enter-view-only-mode-when-browsing-emacs-source-code-from-help/3681#3681][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (dir-locals-set-class-variables
   'emacs
   '((nil . ((buffer-read-only . t)
             (show-trailing-whitespace . nil)
             (tab-width . 8)
             (eval . (whitespace-mode -1))
             ;; (eval . (when buffer-file-name
             ;;           (setq-local view-no-disable-on-exit t)
             ;;           (view-mode-enter)))
             ))))

  ;; (dir-locals-set-directory-class (expand-file-name "/usr/local/share/emacs") 'emacs)
  (dir-locals-set-directory-class "/usr/local/Cellar/emacs" 'emacs)
  ;; (dir-locals-set-directory-class "~/.emacs.d/elpa" 'emacs)
  (dir-locals-set-directory-class "~/dotfiles/emacs.d/elpa" 'emacs)
  (dir-locals-set-directory-class "~/dotfiles/emacs.d/el-get" 'emacs)

  ;; temp-mode.el
  ;; Temporary minor mode
  ;; Main use is to enable it only in specific buffers to achieve the goal of
  ;; buffer-specific keymaps

  ;; (defvar sd/temp-mode-map (make-sparse-keymap)
  ;;   "Keymap while temp-mode is active.")

  ;; ;;;###autoload
  ;; (define-minor-mode sd/temp-mode
  ;;   "A temporary minor mode to be activated only specific to a buffer."
  ;;   nil
  ;;   :lighter " Temp"
  ;;   sd/temp-mode-map)

  ;; (defun sd/temp-hook ()
  ;;   (if sd/temp-mode
  ;;       (progn
  ;;      (define-key sd/temp-mode-map (kbd "q") 'quit-window))))

  ;; (add-hook 'lispy-mode-hook (lambda ()
  ;;                           (sd/temp-hook)))
#+END_SRC

** Info plus
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (el-get-bundle info+
    :url "https://raw.githubusercontent.com/emacsmirror/emacswiki.org/master/info+.el"
    ;; (require 'info+)
    )

  (with-eval-after-load 'info
    (require 'info+))
#+END_SRC

** advice info
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/info-mode ()
    (interactive)
    (unless (equal major-mode 'Info-mode)
      (unless (> (length (window-list)) 1)
        (split-window-right))
      (other-window 1)
      ;; (info)
      ))

  ;; (global-set-key (kbd "C-h i") 'sd/info-mode)

  ;; open Info buffer in other window instead of current window
  (defadvice info (before my-info (&optional file buf) activate)
    (sd/info-mode))

  (defadvice Info-exit (after my-info-exit activate)
    (sd/delete-current-window))
#+END_SRC

** Demo It
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (el-get-bundle howardabrams/demo-it)

  (use-package org-tree-slide
    :ensure t)

  ;; (use-package yasnippet
  ;;   :ensure t)
#+END_SRC

** Presentation
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package org-tree-slide
    :ensure
    :config
    ;; (define-key org-mode-map "\C-ccp" 'org-tree-slide-mode)
    (define-key org-tree-slide-mode-map (kbd "<ESC>") 'org-tree-slide-content)
    (define-key org-tree-slide-mode-map (kbd "<SPACE>") 'org-tree-slide-move-next-tree)
    (define-key org-tree-slide-mode-map [escape] 'org-tree-slide-move-previous-tree))
#+END_SRC

** pdf-tools
#+BEGIN_SRC sh
  brew install poppler
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package pdf-tools
    :ensure t
    :init
    ;; run to complete the installation
    (pdf-tools-install)
    :config
    (add-to-list 'auto-mode-alist '("\.pdf$" . pdf-view-mode))
    (add-hook 'pdf-outline-buffer-mode-hook #'sd/pdf-outline-map))

  (defun sd/pdf-outline-map ()
    "My keybindings in pdf-outline-map"
    (interactive)
    (define-key pdf-outline-buffer-mode-map (kbd "C-o") nil)
    (define-key pdf-outline-buffer-mode-map (kbd "i") 'outline-toggle-children)
    (define-key pdf-outline-buffer-mode-map (kbd "j") 'next-line)
    (define-key pdf-outline-buffer-mode-map (kbd "k") 'previous-line))
#+END_SRC

** help-mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/help-mode-hook ()
    "Mapping for help mode"
    (define-key help-mode-map "j" 'next-line)
    (define-key help-mode-map "k" 'previous-line)
    (define-key help-mode-map "h" 'forward-char)
    (define-key help-mode-map "l" 'forward-char)
    (define-key help-mode-map "H" 'describe-mode)
    (define-key help-mode-map "v" 'recenter-top-bottom)
    (define-key help-mode-map "i" 'forward-button)
    (define-key help-mode-map "I" 'backward-button)
    (define-key help-mode-map "o" 'ace-link-help))

  (add-hook 'help-mode-hook 'sd/help-mode-hook)
#+END_SRC

** goto-last-change
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package goto-last-change
    :ensure t)
#+END_SRC

** Ag
install =ag=, =the-silver-searcher= by homebrew on mac
#+BEGIN_SRC sh
brew install the-silver-searcher
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ag
    :ensure t)
#+END_SRC

** Local Variable hooks
[[https://www.emacswiki.org/emacs/LocalVariables][LocalVariables]], use =hack-local-variables-hook=, run a hook to set local variable in mode hook
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; make Emacs run a new "local variables hook" for each major mode
  (add-hook 'hack-local-variables-hook 'run-local-vars-mode-hook)

  (defun run-local-vars-mode-hook ()
    "Run a hook for the major-mode after the local variables have been processed."
    (run-hooks (intern (concat (symbol-name major-mode) "-local-vars-hook"))))

  ;;   (add-hook 'c++-mode-local-vars-hook #'sd/c++-mode-local-vars)
#+END_SRC

** Table
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (add-hook 'text-mode-hook 'table-recognize)
#+END_SRC

* Dired
** Dired bindings
=C-o= is defined as a global key for window operation, here unset it in dired mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/dired-key-map ()
    "My keybindings for dired"
    (interactive)
    ;; these two prefix are used globally
    (define-key dired-mode-map (kbd "C-o") nil)
    (define-key dired-mode-map (kbd "M-s") nil)
    ;; toggle hidden files
    (define-key dired-mode-map (kbd "H") 'dired-omit-mode)
    ;; scroll 
    (define-key dired-mode-map (kbd "SPC") 'scroll-up-command)
    (define-key dired-mode-map (kbd "DEL") 'scroll-down-command)
    (define-key dired-mode-map (kbd "j") 'diredp-next-line)
    (define-key dired-mode-map (kbd "k") 'diredp-previous-line)
    (define-key dired-mode-map (kbd "g") 'dired-goto-file)
    ;; (define-key dired-mode-map (kbd "S-SPC") 'scroll-down-command)
    ;; jump to fil/dirs
    (define-key dired-mode-map (kbd "f") 'dired-isearch-filenames)
    ;; subdir
    ;; i dired-maybe-insert-subdir
    ;; o dired-find-file-other-window (switch to other window)
    ;; O dired-display-file
    (define-key dired-mode-map (kbd "G") 'ido-dired)
    (define-key dired-mode-map (kbd "c") 'sd/dired-new-file)
    (define-key dired-mode-map (kbd "h") 'dired-summary)
    (define-key dired-mode-map (kbd "r") 'revert-buffer)
    (define-key dired-mode-map (kbd "l") 'dired-display-file)
    (define-key dired-mode-map [C-backspace] 'dired-up-directory)
    (define-key dired-mode-map (kbd "?") 'describe-mode)
    (define-key dired-mode-map (kbd "z") #'sd/dired-get-size)
    (define-key dired-mode-map (kbd "C-d") 'dired-kill-subdir)
    (define-key dired-mode-map (kbd "M-d") 'dired-kill-subdir)
    (define-key dired-mode-map (kbd "J") 'diredp-next-subdir)
    (define-key dired-mode-map (kbd "TAB") 'diredp-next-subdir)
    (define-key dired-mode-map (kbd "K") 'diredp-prev-subdir)
    (define-key dired-mode-map (kbd "O") 'dired-display-file)
    (define-key dired-mode-map (kbd "I") 'other-window)) 

  (use-package dired
    :config
    (require 'dired-x)
    ;; also load dired+
    (use-package dired+
      :ensure t
      :init (setq diredp-hide-details-initially-flag nil))
    
    (setq dired-omit-mode t)
    (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))
    (add-hook 'dired-mode-hook (lambda ()
                                 (sd/dired-key-map)
                                 (dired-omit-mode))))

  (defadvice dired-summary (around sd/dired-summary activate)
    "Revisied dired summary."
    (interactive)
    (dired-why)
    (message
     "Œî: d-delete, u-ndelete, x-punge, f-ind, o-ther window, R-ename, C-opy, c-create, +new dir, r-evert, /-filter, v-iew, l-ist, z-Size, h-summary, ?-help"))

  (defun sd/dired-high-level-dir ()
    "Go to higher level directory"
    (interactive)
    (find-alternate-file ".."))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/dired-new-file ()
    "Create a new file in dired mode"
    (interactive)
    (call-interactively 'find-file))

  ;; copied from abo-abo's config
  (defun sd/dired-get-size ()
    (interactive)
    (let ((files (dired-get-marked-files)))
      (with-temp-buffer
        (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
        (message
         "Size of all marked files: %s"
         (progn
           (re-search-backward "\\(^[ 0-9.,]+[A-Za-z]+\\).*total$")
           (match-string 1))))))
#+END_SRC

** disable ido when dired new file
When create a new directory, I want to disalbe =ido= completion. see [[http://stackoverflow.com/questions/7479565/emacs-ido-mode-and-creating-new-files-in-directories-it-keeps-changing-the-dire][here]]. Thhis code snippets copied
from [[https://emacs.stackexchange.com/questions/13713/how-to-disable-ido-in-dired-create-directory/13795#13795?newreg%3Ddb17c20f7af3490fb11cf15f1d888e9e][How to disable IDO in ‚Äòdired-create-directory‚Äô]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun mk-anti-ido-advice (func &rest args)
    "Temporarily disable IDO and call function FUNC with arguments ARGS."
    (interactive)
    (let ((read-file-name-function #'read-file-name-default))
      (if (called-interactively-p 'any)
          (call-interactively func)
        (apply func args))))

  (defun mk-disable-ido (command)
    "Disable IDO when command COMMAND is called."
    (advice-add command :around #'mk-anti-ido-advice))
#+END_SRC

Disalble =ido= when new a directory or file in =dired= mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; call the function which you want to disable ido
  (mk-disable-ido 'dired-create-directory)
  (mk-disable-ido 'sd/dired-new-file)
#+END_SRC

** Dired open with
=!= =dired-do-shell-command=
=&= =dired-do-async-shell-command=
here on Mac, just use "open" commands to pen =.pdf=,  =.html= and image files
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq dired-guess-shell-alist-user
        '(("\\.pdf\\'" "open" "okular")
          ("\\.\\(?:djvu\\|eps\\)\\'" "evince")
          ("\\.\\(?:jpg\\|jpeg\\|png\\|gif\\|xpm\\)\\'" "open")
          ("\\.\\(?:xcf\\)\\'" "gimp")
          ("\\.csv\\'" "libreoffice")
          ("\\.tex\\'" "pdflatex" "latex")
          ("\\.\\(?:mp4\\|mkv\\|avi\\|flv\\|ogv\\)\\(?:\\.part\\)?\\'" "mplayer")
          ("\\.\\(?:mp3\\|flac\\)\\'" "rhythmbox")
          ("\\.html?\\'" "open")
          ("\\.dmg\\'" "open")
          ("\\.cue?\\'" "audacious")))


  (defun sd/dired-start-process (cmd &optional file-list)
    (interactive
     (let ((files (dired-get-marked-files
                   t current-prefix-arg)))
       (list
        (unless (eq system-type 'windows-nt)
          (dired-read-shell-command "& on %s: "
                                    current-prefix-arg files))
        files)))
    
    (if (eq system-type 'windows-nt)
        (dolist (file file-list)
          (w32-shell-execute "open" (expand-file-name file)))
      (let (list-switch)
        (start-process
         cmd nil shell-file-name
         shell-command-switch
         (format
          "nohup 1>/dev/null 2>/dev/null %s \"%s\""
          cmd
          ;; (if (and (> (length file-list) 1)
          ;;          (setq list-switch
          ;;                (cadr (assoc cmd ora-dired-filelist-cmd))))
          ;;     (format "%s %s" cmd list-switch)
          ;;   cmd)
          (mapconcat #'expand-file-name file-list "\" \""))))))
#+END_SRC

** dired-hacks
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package dired-hacks-utils
    :ensure t
    :defer t)
#+END_SRC

** dired-narrow
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;;narrow dired to match filter
  (use-package dired-narrow
    :ensure t
    :commands (dired-narrow)
    :bind (:map dired-mode-map
                ("/" . dired-narrow)))
#+END_SRC

* Ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key (kbd "s-b") 'ibuffer)

  (with-eval-after-load 'ibuffer
    (define-key ibuffer-mode-map (kbd "C-o") nil)
    (define-key ibuffer-mode-map (kbd "j") 'ibuffer-forward-line)
    (define-key ibuffer-mode-map (kbd "k") 'ibuffer-backward-line)
    (define-key ibuffer-mode-map (kbd "r") 'ibuffer-update)
    (define-key ibuffer-mode-map (kbd "g") 'ibuffer-jump-to-buffer)
    (define-key ibuffer-mode-map (kbd "h") 'sd/ibuffer-summary))

  (defun sd/ibuffer-summary ()
    "Show summary of keybindings in ibuffer mode"
    (interactive)
    (message
     "Œí: m|u - (un)mark, /-filter, //-remove filter, t, RET, g, k, S, D, Q; q to quit; h for help"))
#+END_SRC

* Completion
** company mode and company-statistics
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package company
    :ensure t
    :diminish company-mode
    :init (setq company-idle-delay 0.1)
    (setq company-selection-wrap-around t)
    :config
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
     ;; should map both (kbd "TAB") and [tab],https://github.com/company-mode/company-mode/issues/75
    (define-key company-active-map (kbd "TAB") #'company-complete-selection)
    (define-key company-active-map [tab] #'company-complete-selection)
    (global-company-mode))

  (use-package company-statistics
    :ensure t
    :config
    (company-statistics-mode))
#+END_SRC

** YASnippet
*** yasnippet
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package yasnippet
    :ensure t
    :defer t
    :init
    (add-hook 'prog-mode-hook #'yas-minor-mode)
    :config
    (yas-reload-all))
#+END_SRC


** company and yasnippet
Add yasnippet as the company candidates
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;Add yasnippet support for all company backends
  ;https://github.com/syl20bnr/spacemacs/pull/179
  (defvar company-mode/enable-yas t
    "Enable yasnippet for all backends.")

  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+END_SRC

Refer, [[http://emacs.stackexchange.com/questions/7908/how-to-make-yasnippet-and-company-work-nicer][how-to-make-yasnippet-and-company-work-nicer]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun check-expansion ()
    (save-excursion
      (if (looking-at "\\_>") t
        (backward-char 1)
        (if (looking-at "\\.") t
          (backward-char 1)
          (if (looking-at "->") t nil)))))

  (defun do-yas-expand ()
    (let ((yas/fallback-behavior 'return-nil))
      (yas/expand)))

  (defun tab-indent-or-complete ()
    (interactive)
    (cond
     ((minibufferp)
      (minibuffer-complete))
     (t
      (indent-for-tab-command)
      (if (or (not yas/minor-mode)
              (null (do-yas-expand)))
          (if (check-expansion)
              (progn
                (company-manual-begin)
                (if (null company-candidates)
                    (progn
                      (company-abort)
                      (indent-for-tab-command)))))))))

  (defun tab-complete-or-next-field ()
    (interactive)
    (if (or (not yas/minor-mode)
            (null (do-yas-expand)))
        (if company-candidates
            (company-complete-selection)
          (if (check-expansion)
              (progn
                (company-manual-begin)
                (if (null company-candidates)
                    (progn
                      (company-abort)
                      (yas-next-field))))
            (yas-next-field)))))

  (defun expand-snippet-or-complete-selection ()
    (interactive)
    (if (or (not yas/minor-mode)
            (null (do-yas-expand))
            (company-abort))
        (company-complete-selection)))

  (defun abort-company-or-yas ()
    (interactive)
    (if (null company-candidates)
        (yas-abort-snippet)
      (company-abort)))

  '
  ;; (require 'company)
  ;; (require 'yasnippet)


  ;; (global-set-key [tab] 'tab-indent-or-complete)
  ;; (global-set-key (kbd "TAB") 'tab-indent-or-complete)
  ;; (global-set-key [(control return)] 'company-complete-common)

  ;; (define-key company-active-map [tab] 'expand-snippet-or-complete-selection)
  ;; (define-key company-active-map (kbd "TAB") 'expand-snippet-or-complete-selection)

  ;; (define-key yas-minor-mode-map [tab] nil)
  ;; (define-key yas-minor-mode-map (kbd "TAB") nil)

  ;; (define-key yas-keymap [tab] 'tab-complete-or-next-field)
  ;; (define-key yas-keymap (kbd "TAB") 'tab-complete-or-next-field)
  ;; (define-key yas-keymap [(control tab)] 'yas-next-field)
  ;; (define-key yas-keymap (kbd "C-g") 'abort-company-or-yas)
#+END_SRC

* Libs
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package s
    :ensure t)
#+END_SRC

* Programming Language
** Emacs Lisp
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package color-identifiers-mode
    :ensure t
    :init
    (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)

    :diminish color-identifiers-mode)

  (global-prettify-symbols-mode t)
#+END_SRC

In Lisp Mode, =M-o= is defined, but I use this for global hydra window. So here disable this key
bindings in =lispy-mode-map= after loaded. see [[http://stackoverflow.com/questions/298048/how-to-handle-conflicting-keybindings][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package lispy
    :ensure t
    :init
    (eval-after-load "lispy"
      `(progn
         (define-key lispy-mode-map (kbd "M-o") nil)))
    :config
    (add-hook 'emacs-lisp-mode-hook (lambda () (lispy-mode 1))))
#+END_SRC

** Perl
*** CPerl mode
[[https://www.emacswiki.org/emacs/CPerlMode][CPerl mode]] has more features than =PerlMode= for perl programming. Alias this to =CPerlMode=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defalias 'perl-mode 'cperl-mode)

  ;; (setq cperl-hairy t)
  ;; Turns on most of the CPerlMode options
  (setq cperl-auto-newline t)
  (setq cperl-highlight-variables-indiscriminately t)
  ;(setq cperl-indent-level 4)
  ;(setq cperl-continued-statement-offset 4)
  (setq cperl-close-paren-offset -4)
  (setq cperl-indent-parents-as-block t)
  (setq cperl-tab-always-indent t)
  ;(setq cperl-brace-offset  0)

  (add-hook 'cperl-mode-hook
            '(lambda ()
               (cperl-set-style "C++")))

  (defalias 'perldoc 'cperl-perldoc)
#+END_SRC

*** Perl template
Refer [[https://www.emacswiki.org/emacs/AutoInsertMode][AutoInsertMode]] Wiki
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.pl\\'" . "Perl skeleton")
       '(
         "Empty"
         "#!/usr/bin/perl -w" \n
         \n
         "use strict;" >  \n \n
         > _
         )))
#+END_SRC

*** Perl Keywords
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (font-lock-add-keywords 'cperl-mode
                          '(("\\(say\\)" . cperl-nonoverridable-face)
                            ("\\([0-9.]\\)*" . font-lock-constant-face)
                            ("\".*\\(\\\n\\).*\"" . font-lock-constant-face)
                            ("\n" . font-lock-constant-face)
                            ("\\(^#!.*\\)$" .  cperl-nonoverridable-face)))

    ;; (font-lock-add-keywords 'Man-mode
    ;;                         '(("\\(NAME\\)" . font-lock-function-name-face)))

#+END_SRC

*** Run Perl
Change the compile-command to set the default command run when call =compile=
Mapping =s-r= (on Mac, it's =Command + R= to run the script. Here =current-prefix-arg= is set
to call =compilation=  interactively.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun my-perl-hook ()
    (progn
      (setq-local compilation-read-command nil)
      (set (make-local-variable 'compile-command)
           (concat "/usr/bin/perl "
                   (if buffer-file-name
                       (shell-quote-argument buffer-file-name))))
      (local-set-key (kbd "s-r")
                     (lambda ()
                       (interactive)
                                          ;                       (setq current-prefix-arg '(4)) ; C-u
                       (call-interactively 'compile)))))

  (add-hook 'cperl-mode-hook 'my-perl-hook)
#+END_SRC

** C & C++
C/C++ ide tools
1. completion (file name, function name, variable name)
2. template yasnippet (keywords, if, function)
3. tags jump
*** c/c++ style
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq c-default-style "stroustrup"
        c-basic-offset 4)

  ;; "C-M-j" is my global binding for avy goto line below
  ;; disable it in c mode
  (mapcar #'(lambda (map)
             (define-key map (kbd "C-M-j") nil))
          (list c-mode-map
                c++-mode-map
                objc-mode-map))

  ;; objective c
  (add-to-list 'auto-mode-alist '("\\.mm\\'" . objc-mode))
#+END_SRC

*** irony
**** install irony server
Install clang, on mac, it has =libclang.dylib=, but no develop headers. Install by =brew=
#+BEGIN_SRC sh
  brew install llvm --with-clang
#+END_SRC

then install irony searver, and =LIBCLANG_LIBRARY= and =LIBCLANG_INCLUDE_DIR= accordingly
#+BEGIN_SRC emacs-lisp :tangle no :results silent
  (irony-install-server)
#+END_SRC

#+BEGIN_SRC sh
  cmake -DLIBCLANG_LIBRARY\=/usr/local/Cellar/llvm/3.6.2/lib/libclang.dylib \
        -DLIBCLANG_INCLUDE_DIR=/usr/local/Cellar/llvm/3.6.2/include \
        -DCMAKE_INSTALL_PREFIX\=/Users/peli3/.emacs.d/irony/ \
        /Users/peli3/.emacs.d/elpa/irony-20160713.1245/server && cmake --build . --use-stderr --config Release --target install 
#+END_SRC

**** irony config
irony-mode-hook, copied from [[https://github.com/Sarcasm/irony-mode][irony-mode]] github
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'objc-mode-hook 'irony-mode))

  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function

  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point]
      'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol]
      'irony-completion-at-point-async))

  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

  (add-hook 'c++-mode-local-vars-hook #'sd/c++-mode-local-vars)

  ;; add C++ completions, because by default c++ file can not complete
  ;; c++ std functions, another method is create .dir-local.el file, for p
  ;; for project see irony
  (defun sd/c++-mode-local-vars ()
    (setq irony--compile-options
        '("-std=c++11"
          "-stdlib=libc++"
          "-I/usr/include/c++/4.2.1")))
#+END_SRC

irony-company
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package company-irony
    :ensure t)

  (use-package flycheck-irony
    :ensure t)

  (use-package company-c-headers
    :ensure t
    :config
    (add-to-list 'company-c-headers-path-system "/usr/include/c++/4.2.1/"))

  ;; (with-eval-after-load 'company
  ;;   (add-to-list 'company-backends 'company-irony)
  ;;   (add-to-list 'company-backends 'company-c-headers))

  (with-eval-after-load 'company
    (push  '(company-irony :with company-yasnippet) company-backends)
    (push  '(company-c-headers :with company-yasnippet) company-backends))

  (with-eval-after-load 'flycheck
    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
#+END_SRC

*** flycheck
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package flycheck
    :ensure t)
#+END_SRC

*** gtags
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package ggtags
    :ensure t
    :config
    (define-key ggtags-mode-map (kbd "M-g d") 'ggtags-find-definition)
    (define-key ggtags-mode-map (kbd "M-g r") 'ggtags-find-reference)
    (define-key ggtags-mode-map (kbd "M-g r") 'ggtags-find-reference)
    (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
    (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
    (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
    (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
    (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
    (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags))

  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                (ggtags-mode 1))))

  (require 'cc-mode)
  (require 'semantic)

  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1)

  (semantic-mode 1)
#+END_SRC

*** google C style
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package google-c-style
    :ensure t
    :config
    (add-hook 'c-mode-hook 'google-set-c-style)
    (add-hook 'c++-mode-hook 'google-set-c-style))
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package lua-mode
    :ensure t)
#+END_SRC

* Compile
Set the environments vairables in compilation mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package compile
    :commands compile
    :config
    (setq compilation-environment (cons "LC_ALL=C" compilation-environment))
    (setq compilation-auto-jump-to-first-error t)
    (setq compilation-auto-jump-to-next t)
    (setq compilation-scroll-output 'first-error))

  ;; super-r to compile
  (with-eval-after-load "compile"
    (define-key compilation-mode-map (kbd "C-o") nil)
    (define-key compilation-mode-map (kbd "n") 'compilation-next-error)
    (define-key compilation-mode-map (kbd "p") 'compilation-previous-error)
    (define-key compilation-mode-map (kbd "r") #'recompile))

  (global-set-key (kbd "s-r") 'compile)
#+END_SRC

* Auto-Insert
** Enable auto-insert mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (auto-insert-mode t)
  (setq auto-insert-query nil)
#+END_SRC

** C++ Auto Insert
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.cpp\\|.cc\\'" . "C++ skeleton")
       '(
         "Short description:"
         "/*"
         "\n * " (file-name-nondirectory (buffer-file-name))
         "\n */" > \n \n
         "#include <iostream>" \n
         "//#include \""
         (file-name-sans-extension
          (file-name-nondirectory (buffer-file-name)))
         ".hpp\"" \n \n
         "using namespace std;" \n \n
         "int main ()"
         "\n{" \n 
         > _ \n
         "return 0;"
         "\n}" > \n
         )))

  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.c\\'" . "C skeleton")
       '(
         "Short description:"
         "/*\n"
         " * " (file-name-nondirectory (buffer-file-name)) "\n"
         " */" > \n \n
         "#include <stdio.h>" \n
         "//#include \""
         (file-name-sans-extension
          (file-name-nondirectory (buffer-file-name)))
         ".h\"" \n \n
         "int main ()\n"
         "{" \n
         > _ \n
         "return 0;\n"
         "}" > \n
         )))

  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.h\\|.hpp\\'" . "c/c++ header")
       '((s-upcase (s-snake-case (file-name-nondirectory buffer-file-name)))
         "#ifndef " str n "#define " str "\n\n" _ "\n\n#endif  // " str)))
#+END_SRC

** Python template
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.\\(py\\)\\'" . "Python skeleton")
       '(
         "Empty"
         "#import os,sys" \n
         \n \n
         )))
#+END_SRC

** Elisp 
Emacs lisp auto-insert, based on the default module in =autoinsert.el=, but replace =completing-read= as 
=completing-read-ido-ubiquitous= to fix the edge case of that =ido= cannot handle.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.el\\'" . "my Emacs Lisp header")
       '(
         "Short description: "
         ";;; " (file-name-nondirectory (buffer-file-name)) " --- " str
         (make-string (max 2 (- 80 (current-column) 27)) ?\s)
         "-*- lexical-binding: t; -*-" '(setq lexical-binding t)
         "\n
  ;; Copyright (C) " (format-time-string "%Y") "  "
         (getenv "ORGANIZATION") | (progn user-full-name) "

  ;; Author: " (user-full-name)
         '(if (search-backward "&" (line-beginning-position) t)
              (replace-match (capitalize (user-login-name)) t t))
         '(end-of-line 1) " <" (progn user-mail-address) ">
  ;; Keywords: "
         '(require 'finder)
         ;;'(setq v1 (apply 'vector (mapcar 'car finder-known-keywords)))
         '(setq v1 (mapcar (lambda (x) (list (symbol-name (car x))))
                           finder-known-keywords)
                v2 (mapconcat (lambda (x) (format "%12s:  %s" (car x) (cdr x)))
                              finder-known-keywords
                              "\n"))
         ((let ((minibuffer-help-form v2))
            (completing-read-ido-ubiquitous "Keyword, C-h: " v1 nil t))
          str ", ") & -2 "

  \;; This program is free software; you can redistribute it and/or modify
  \;; it under the terms of the GNU General Public License as published by
  \;; the Free Software Foundation, either version 3 of the License, or
  \;; (at your option) any later version.

  \;; This program is distributed in the hope that it will be useful,
  \;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  \;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  \;; GNU General Public License for more details.

  \;; You should have received a copy of the GNU General Public License
  \;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

  \;;; Commentary:

  \;; " _ "

  \;;; Code:


  \(provide '"
         (file-name-base)
         ")
  \;;; " (file-name-nondirectory (buffer-file-name)) " ends here\n")))
#+END_SRC

** Org file template
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (eval-after-load 'autoinsert
    '(define-auto-insert '("\\.\\(org\\)\\'" . "Org-mode skeleton")
       '(
         "title: "
         "#+TITLE: " str (make-string 30 ?\s) > \n
         "#+AUTHOR: Peng Li\n"
         "#+EMAIL: seudut@gmail.com\n"
         "#+DATE: " (shell-command-to-string "echo -n $(date +%Y-%m-%d)") > \n
         > \n
         > _)))
#+END_SRC

* Markdown mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package markdown-preview-eww
    :ensure t)
#+END_SRC

* Gnus
** Gmail setting 
Refer [[https://www.emacswiki.org/emacs/GnusGmail][GnusGmail]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq user-mail-address "seudut@gmail.com"
        user-full-name "Peng Li")

  (setq gnus-select-method
        '(nnimap "gmail"
                 (nnimap-address "imap.gmail.com")
                 (nnimap-server-port "imaps")
                 (nnimap-stream ssl)))

  (setq smtpmail-smtp-service 587
        gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

  ;; Use gmail sending mail
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
        smtpmail-auth-credentials '(("smtp.gmail.com" 587 "seudut@gmail.com" nil))
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        starttls-use-gnutls t)
#+END_SRC

And put the following in =~/.authinfo= file, replacing =<USE>= with your email address
and =<PASSWORD>= with the password
#+BEGIN_EXAMPLE
  machine imap.gmail.com login <USER> password <PASSWORD> port imaps
  machine smtp.gmail.com login <USER> password <PASSWORD> port 587
#+END_EXAMPLE

Then Run =M-x gnus=

** Group buffer
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package gnus
    :init
    (setq gnus-permanently-visible-groups "\.*")
    :config
    (cond (window-system
           (setq custom-background-mode 'light)
           (defface my-group-face-1
             '((t (:foreground "Red" :bold t))) "First group face")
           (defface my-group-face-2
             '((t (:foreground "DarkSeaGreen4" :bold t)))
             "Second group face")
           (defface my-group-face-3
             '((t (:foreground "Green4" :bold t))) "Third group face")
           (defface my-group-face-4
             '((t (:foreground "SteelBlue" :bold t))) "Fourth group face")
           (defface my-group-face-5
             '((t (:foreground "Blue" :bold t))) "Fifth group face")))
    (setq gnus-group-highlight
          '(((> unread 200) . my-group-face-1)
            ((and (< level 3) (zerop unread)) . my-group-face-2)
            ((< level 3) . my-group-face-3)
            ((zerop unread) . my-group-face-4)
            (t . my-group-face-5))))


  ;; key-
  (add-hook 'gnus-group-mode-hook (lambda ()
                                    (define-key gnus-group-mode-map "k" 'gnus-group-prev-group)
                                    (define-key gnus-group-mode-map "j" 'gnus-group-next-group)
                                    (define-key gnus-group-mode-map "g" 'gnus-group-jump-to-group)
                                    (define-key gnus-group-mode-map "v" (lambda () (interactive) (gnus-group-select-group t)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq gnus-fetch-old-headers 't)



  (setq gnus-extract-address-components
        'mail-extract-address-components)
  ;; summary buffer 
  (setq gnus-summary-line-format "%U%R%z%I%(%[%-20,20f%]%)  %s%-80=   %11&user-date;\n")
  (setq gnus-user-date-format-alist '(((gnus-seconds-today) . "%H:%M")
                                      ((+ 86400 (gnus-seconds-today)) . "%a %H:%M")
                                      (604800 . "%a, %b %-d")
                                      (15778476 . "%b %-d")
                                      (t . "%Y-%m-%d")))

  (setq gnus-thread-sort-functions '((not gnus-thread-sort-by-number)))
  (setq gnus-unread-mark ?\.)
  (setq gnus-use-correct-string-widths t)

  ;; thread
  (setq gnus-thread-hide-subtree t)

  ;; (with-eval-after-load 'gnus-summary-mode
  ;;   (define-key gnus-summary-mode-map (kbd "C-o") 'sd/hydra-window/body))

  (add-hook 'gnus-summary-mode-hook (lambda ()
                                      (define-key gnus-summary-mode-map (kbd "C-o") nil)))


#+END_SRC

** Windows layout
See [[https://www.emacswiki.org/emacs/GnusWindowLayout][GnusWindowLayout]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (gnus-add-configuration
   '(summary
     (horizontal 1.0
                 (vertical 35
                           (group 1.0))
                 (vertical 1.0
                           (summary 1.0 poine)))))

  (gnus-add-configuration
   '(article
     (horizontal 1.0
                 (vertical 35
                           (group 1.0))
                 (vertical 1.0
                           (summary 0.50 point)
                           (article 1.0)))))

  (with-eval-after-load 'gnus-group-mode
    (gnus-group-select-group "INBOX"))
  ;; (add-hook 'gnus-group-mode-map (lambda ()
  ;;                               (gnus-group-select-group "INBOX")))
#+END_SRC

* Gnu Plot
Install =gnuplot= on Mac
#+BEGIN_SRC sh
  brew install gnuplot --with-qt
#+END_SRC

To fix some issue that =toolbar-make-button-list= is void, see the [[https://github.com/bruceravel/gnuplot-mode/issues/31][issue]], here I set some variable as =nil=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package gnuplot
    :ensure
    :init
    (setq gnuplot-help-xpm nil)
    (setq gnuplot-line-xpm nil)
    (setq gnuplot-region-xpm nil)
    (setq gnuplot-buffer-xpm nil)
    (setq gnuplot-doc-xpm nil))
#+END_SRC

Use =gnuplot= on =Org-mode= file, see [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][ob-doc-gnuplot]]
#+BEGIN_SRC gnuplot :exports code :file ./temp/file.png
  reset

  set title "Putting it All Together"

  set xlabel "X"
  set xrange [-8:8]
  set xtics -8,2,8


  set ylabel "Y"
  set yrange [-20:70]
  set ytics -20,10,70

  f(x) = x**2
  g(x) = x**3
  h(x) = 10*sqrt(abs(x))

  plot f(x) w lp lw 1, g(x) w p lw 2, h(x) w l lw 3
#+END_SRC

#+RESULTS:
[[file:./temp/file.png]]
* Ediff
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (with-eval-after-load 'ediff
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (add-hook 'ediff-startup-hook 'ediff-toggle-wide-display)
    (add-hook 'ediff-cleanup-hook 'ediff-toggle-wide-display)
    (add-hook 'ediff-suspend-hook 'ediff-toggle-wide-display))
#+END_SRC

* Entertainment
** GnoGo
Play Go in Emacs, gnugo xpm refert [[https://github.com/okanotor/dotemacs/blob/f95b774cb292d1169748bc0a62ba647bbd8c0652/etc/my-inits/my-inits-gnugo.el][to here]]. start at image display mode and grid mode
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package gnugo
    :ensure t
    :defer t
    :init
    (require 'gnugo-imgen)
    (setq gnugo-xpms 'gnugo-imgen-create-xpms)
    (add-hook 'gnugo-start-game-hook '(lambda ()
                                        (gnugo-image-display-mode)
                                        (gnugo-grid-mode)))
    :config
    (add-to-list 'gnugo-option-history (format "--boardsize 19 --color black --level 1")))
#+END_SRC

** Emms
We can use [[https://www.gnu.org/software/emms/quickstart.html][Emms]] for multimedia in Emacs
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package emms
    :ensure t
    :init
    (setq emms-directory (concat sd-temp-directory "emms"))
    (setq emms-source-file-default-directory "~/Music/")
    :config
    (emms-standard)
    (emms-default-players)
    (define-emms-simple-player mplayer '(file url)
      (regexp-opt '(".ogg" ".mp3" ".mgp" ".wav" ".wmv" ".wma" ".ape"
                    ".mov" ".avi" ".ogm" ".asf" ".mkv" ".divx" ".mpeg"
                    "http://" "mms://" ".rm" ".rmvb" ".mp4" ".flac" ".vob"
                    ".m4a" ".flv" ".ogv" ".pls"))
      "mplayer" "-slave" "-quiet" "-really-quiet" "-fullscreen")
    (emms-history-load))
#+END_SRC

* Dictionary
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package bing-dict
    :ensure t
    :init
    (global-set-key (kbd "s-d") 'bing-dict-brief)
    :commands (bing-dict-brief))
#+END_SRC

* Key Bindings
Here are some global key bindings for basic editting
** Esc in minibuffer
Use =ESC= to exit minibuffer. Also I map =Super-h= the same as =C-g=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (define-key minibuffer-local-map [escape] 'keyboard-escape-quit)
  (define-key minibuffer-local-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-ns-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-isearch-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-completion-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-must-match-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-must-match-filename-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-filename-completion-map [escape]  'keyboard-escape-quit)
  (define-key minibuffer-local-filename-must-match-map [escape]  'keyboard-escape-quit)

  ;; Also map s-h same as C-g
  (define-key minibuffer-local-map (kbd "s-h") 'keyboard-escape-quit)
#+END_SRC

** Project operations - =super=
*** Projectile
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package projectile
    :ensure t
    :init
    (setq projectile-enable-caching t)
    (setq projectile-switch-project-action (lambda ()
                                             (projectile-dired)
                                             (sd/project-switch-action)))
    (setq projectile-cache-file (concat sd-temp-directory "projectile.cache"))
    :config
    (add-to-list 'projectile-globally-ignored-files "GTAGS")
    (projectile-global-mode t))

  (use-package persp-projectile
    :ensure t
    :config
    (persp-mode)
    :bind
    (:map projectile-mode-map
          ("s-t" . projectile-persp-switch-project)))

  ;; (defun sd/change-default-directory (buffer dir)
  ;;   "change defafult directory of buffer to dir"
  ;;   (with-current-buffer buffer
  ;;     (cd dir)))

  ;; change default-directory of scratch buffer to projectile-project-root 
  (defun sd/project-switch-action ()
    "Change default-directory of scratch buffer to current projectile-project-root directory"
    (interactive)
    (dolist (buffer (buffer-list))
      (if (string-match (concat "scratch.*" (projectile-project-name))
                        (buffer-name buffer))
          (let ((root (projectile-project-root)))
            (with-current-buffer buffer
              (cd root)))
        ;; (sd/change-default-directory buffer (projectile-project-root))
        )))
#+END_SRC

*** project config =super= keybindings
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; (global-set-key (kbd "s-h") 'keyboard-quit)
  ;; (global-set-key (kbd "s-j") 'ido-switch-buffer)
  ;; (global-set-key (kbd "s-k") 'ido-find-file)
  ;; (global-set-key (kbd "s-l") 'sd/delete-current-window)
  ;; s-l  -->  goto-line
  ;; (global-set-key (kbd "s-/") 'swiper)
  ;; s-;  -->
  ;; s-'  -->  'next-multiframe-window
  (global-set-key (kbd "<s-return>") 'toggle-frame-fullscreen)

  (global-set-key (kbd "s-f") 'projectile-find-file)
  (global-set-key (kbd "s-`") 'mode-line-other-buffer)

  (global-set-key (kbd "s-n") 'persp-next)
  (global-set-key (kbd "s-p") 'persp-prev)
  (global-set-key (kbd "s-;") 'persp-switch-last)

  (global-set-key (kbd "s-=") 'text-scale-increase)
  (global-set-key (kbd "s--") 'text-scale-decrease)

  ;; (global-set-key (kbd "s-u") 'undo-tree-visualize)


  ;; someothers default mapping on super (command) key
  ;; s-s save-buffer
  ;; s-k kill-this-buffer


  ;; s-h  -->  ns-do-hide-emacs
  ;; s-j  -->  ido-switch-buffer  +
  ;; s-k  -->  kill-this-buffer
  ;; s-l  -->  goto-line
  ;; s-;  -->  undefined
  ;; s-'  -->  next-multiframe-window
  ;; s-ret --> toggle-frame-fullscreen +

  ;; s-y  -->  ns-paste-secondary
  ;; s-u  -->  revert-buffer
  ;; s-i  -->  undefined - but used for iterm globally
  ;; s-o  -->  used for emacs globally
  ;; s-p  -->  projectile-persp-switch-project  +  
  ;; s-[  -->  next-buffer  +    
  ;; s-]  -->  previous-buffer +

  ;; s-0  -->  undefined
  ;; s-9  -->  undefined
  ;; s-8  -->  undefined
  ;; s-7  -->  undefined
  ;; s-6  -->  undefined
  ;; s--  -->  center-line
  ;; s-=  -->  undefined

  ;; s-n  -->  make-frame
  ;; s-m  -->  iconify-frame
  ;; s-b  -->  undefined
  ;; s-,  -->  customize
  ;; s-.  -->  undefined
  ;; s-/  -->  undefined

  ;; s-g  -->  isearch-repeat-forward
  ;; s-f  -->  projectile-find-file   +
  ;; s-d  -->  isearch-repeat-background
  ;; s-s  -->  save-buffer
  ;; s-a  -->  make-whole-buffer

  ;; s-b  -->  undefined
  ;; s-v  -->  yank
  ;; s-c  -->  ns-copy-including-secondary

  ;; s-t  -->  ns-popup-font-panel
  ;; s-r  -->  undefined
  ;; s-e  -->  isearch-yanqk-kill
  ;; s-w  -->  delete-frame
  ;; s-q  -->  same-buffers-kill-emacs

  ;; s-`  -->  other-frame
#+END_SRC

** Windown & Buffer - =C-o=
Defind a =hydra= function for windows, buffer & bookmark operations. And map it to =C-o= globally.
Most use =C-o C-o= to switch buffers; =C-o x, v= to split window; =C-o o= to delete other windows
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (winner-mode 1)

  (defun sd/delete-current-window ()
    (interactive)
    (if (> (length (window-list)) 1)
        (delete-window)
      (message "Only one Windows now!")))

  (defun sd/toggle-max-windows ()
    "Set maximize current if there are multiple windows, if only
  one window, window undo"
    (interactive)
    (if (equal  (length (window-list)) 1)
        (winner-undo)
      (delete-other-windows)))

  (defhydra sd/hydra-window (:color red :columns nil)
    "Window"
    ;; windows switch
    ("h" windmove-left nil :exit t)
    ("j" windmove-down nil :exit t)
    ("k" windmove-up nil :exit t)
    ("l" windmove-right nil :exit t)
    ("C-o" other-window nil :exit t)
    ;; window resize
    ("H" hydra-move-splitter-left nil)
    ("J" hydra-move-splitter-down nil)
    ("K" hydra-move-splitter-up nil)
    ("L" hydra-move-splitter-right nil)
    ;; windows split
    ("v" (lambda ()
           (interactive)
           (split-window-right)
           (windmove-right))
     "vert" :exit t)
    ("x" (lambda ()
           (interactive)
           (split-window-below)
           (windmove-down))
     "horz" :exit t)
    ;; buffer / windows switch
    ("o" sd/toggle-max-windows "one" :exit t)
    ("C-k" sd/delete-current-window "del" :exit t)
    ("C-d" (lambda ()
             (interactive)
             (kill-buffer)
             (sd/delete-current-window))
     "kill" :exit t)

    ;; ace-window
    ;; ("'" other-window "other" :exit t)
    ;; ("a" ace-window "ace")
    ("s" ace-swap-window "swap")
    ("D" ace-delete-window "ace-one" :exit t)
    ;; ("i" ace-maximize-window "ace-one" :exit t)
    ;; Windows undo - redo
    ("u" (progn (winner-undo) (setq this-command 'winner-undo)) "undo")
    ("r" (progn (winner-redo) (setq this-command 'winner-redo)) "redo")
    
    ;; ibuffer, dired, eshell, bookmarks
    ;; ("C-i" other-window nil :exit t)
    ("C-b" ido-switch-buffer nil :exit t)
    ("C-f" projectile-find-file nil :exit t)
    ("C-p" persp-switch :exit t)

    ;; other special buffers
    ("d" sd/project-or-dired-jump nil :exit t)
    ("b" ibuffer nil :exit t)
    ("t" multi-term nil :exit t)
    ("e" sd/toggle-project-eshell nil :exit t)
    ("m" bookmark-jump-other-window nil :exit t)
    ("M" bookmark-set nil :exit t)
    ("g" magit-status nil :exit t)
    ;; ("p" paradox-list-packages nil :exit t)

    ;; quit
    ("q" nil "cancel")
    ("<ESC>" nil)
    ("C-h" nil nil :exit t)
    ("C-j" nil nil :exit t)
    ;; ("C-k" nil :exit t)
    ("C-l" nil nil :exit t)
    ("C-;" nil nil :exit t)
    ("n" nil nil :exit t)
    ("[" nil nil :exit t)
    ("]" nil nil :exit t)
    ("f" nil))

  (global-unset-key (kbd "C-o"))
  (global-set-key (kbd "C-o") 'sd/hydra-window/body)

  (defun sd/project-or-dired-jump ()
    "If under project, jump to the root directory, otherwise
  jump to dired of current file"
    (interactive)
    (if (projectile-project-p)
        (projectile-dired)
      (dired-jump)))
#+END_SRC

** Motion
- =C-M-=
[[https://www.masteringemacs.org/article/effective-editing-movement][effective-editing-movement]]
*** Command Arguments, numeric argumens
=C-u 4= same as =C-4=, =M-4=
*** Basic movement
moving by line / word / 
=C-f=, =C-b=, =C-p=, =C-n=, =M-f=, =M-b=
=C-a=, =C-e=
=M-m= (move first non-whitespace on this line) 
=M-}=, =M-{=, Move forward end of paragraph
=M-a=, =M-e=,  beginning / end of sentence
=C-M-a=, =C-M-e=, move begining of defun
=C-x ]=, =C-x [=, forward/backward one page
=C-v=, =M-v=, =C-M-v=, =C-M-S-v= scroll down/up
=M-<=, =M->=, beginning/end of buffer
=M-r=, Repositiong point

*** Moving by S-expression / List
*** Marks
=C-<SPC>= set marks toggle the region
=C-u C-<SPC>= Jump to the mark, repeated calls go further back the mark ring
=C-x C-x= Exchanges the point and mark.

Stolen [[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode][fixing-mark-commands-transient-mark-mode]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun push-mark-no-activate ()
    "Pushes `point' to `mark-ring' and does not activate the region
     Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
    (interactive)
    (push-mark (point) t nil)
    (message "Pushed mark to ring"))

  ;; (global-set-key (kbd "C-`") 'push-mark-no-activate)

  (defun jump-to-mark ()
    "Jumps to the local mark, respecting the `mark-ring' order.
    This is the same as using \\[set-mark-command] with the prefix argument."
    (interactive)
    (set-mark-command 1))

  ;; (global-set-key (kbd "M-`") 'jump-to-mark)

  (defun exchange-point-and-mark-no-activate ()
    "Identical to \\[exchange-point-and-mark] but will not activate the region."
    (interactive)
    (exchange-point-and-mark)
    (deactivate-mark nil))

  ;; (define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+END_SRC

Show the mark ring using =helm-mark-ring=, also mapping =M-`= to quit minibuffer. so that =M-`= can 
toggle the mark ring. the best way is add a new action and mapping to =helm-source-mark-ring=,  but 
since there is no map such as =helm-mark-ring=map=, so I cannot binding a key to the quit action.
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq mark-ring-max 50)

  (use-package helm
    :ensure t
    :init
    (global-set-key (kbd "M-`") #'helm-mark-ring))

  (define-key minibuffer-local-map (kbd "M-`") 'keyboard-escape-quit)
#+END_SRC

=M-h= marks the next paragraph
=C-x h= marks the whole buffer
=C-M-h= marks the next defun
=C-x C-p= marks the next page
*** Registers
Registers can save text, position, rectangles, file and configuration and other things.
Here for movement, we can use register to save/jump position
=C-x r SPC= store point in register
=C-x r j= jump to register
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package list-register
    :ensure t)
#+END_SRC

*** Bookmarks
As I would like use bookmakr for different buffer/files. to help to swith
different buffer/file quickly. this setting is in Windows/buffer node
=C-x r m= set a bookmarks
=C-x r l= list bookmarks
=C-x r b= jump to bookmarks

*** Search
Search, replace and hightlight will in later paragraph
*** =Avy= for easy motion
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package avy
    :ensure t
    :config
    (avy-setup-default))

  (global-set-key (kbd "C-M-j") 'avy-goto-line-below)
  (global-set-key (kbd "C-M-n") 'avy-goto-line-below)
  (global-set-key (kbd "C-M-k") 'avy-goto-line-above)
  (global-set-key (kbd "C-M-p") 'avy-goto-line-above)

  (global-set-key (kbd "C-M-f") 'avy-goto-word-1-below)
  (global-set-key (kbd "C-M-b") 'avy-goto-word-1-above)

  ;; (global-set-key (kbd "M-g e") 'avy-goto-word-0)
  (global-set-key (kbd "C-M-w") 'avy-goto-char-timer)
  (global-set-key (kbd "C-M-l") 'avy-goto-char-in-line)

  ;; ;; will delete above 
  ;; (global-set-key (kbd "M-g j") 'avy-goto-line-below)
  ;; (global-set-key (kbd "M-g k") 'avy-goto-line-above)
  ;; (global-set-key (kbd "M-g w") 'avy-goto-word-1-below)
  ;; (global-set-key (kbd "M-g b") 'avy-goto-word-1-above)
  ;; (global-set-key (kbd "M-g e") 'avy-goto-word-0)
  ;; (global-set-key (kbd "M-g f") 'avy-goto-char-timer)
  ;; (global-set-key (kbd "M-g c") 'avy-goto-char-in-line)
#+END_SRC

*** =Imenu= goto tag
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key (kbd "M-i") #'counsel-imenu)
  ;; (global-set-key (kbd "M-i") #'imenu)
#+END_SRC

*** Go-to line
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (global-set-key (kbd "M-l") 'goto-line)
#+END_SRC

** Edit
*** basic editting
- cut, yank, =C-w=, =C-y=
- save, revert
- undo, redo - undo-tree
- select, expand-region
- spell check, flyspell

*** Kill ring
=helm-show-kill-ring=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq kill-ring-max 100)                ; default is 60p

  (use-package helm
    :ensure t
    :init
    (global-set-key (kbd "M-y") #'helm-show-kill-ring))
#+END_SRC

*** undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package undo-tree
    :ensure t
    :config
    (define-key undo-tree-visualizer-mode-map "j" 'undo-tree-visualize-redo)
    (define-key undo-tree-visualizer-mode-map "k" 'undo-tree-visualize-undo)
    (define-key undo-tree-visualizer-mode-map "h" 'undo-tree-visualize-switch-branch-left)
    (define-key undo-tree-visualizer-mode-map "l" 'undo-tree-visualize-switch-branch-right)
    (global-undo-tree-mode 1))

  (global-set-key (kbd "s-u") 'undo-tree-visualize)
#+END_SRC

*** flyspell
Stolen from [[https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-spelling.el][here]], hunspell will search dictionary in =DICPATH=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setenv "DICPATH" "/usr/local/share/hunspell")

  (when (executable-find "hunspell")
    (setq-default ispell-program-name "hunspell")
    (setq ispell-really-hunspell t))

  ;; (defun text-mode-hook-setup ()
  ;;   ;; Turn off RUN-TOGETHER option when spell check text-mode
  ;;   (setq-local ispell-extra-args (flyspell-detect-ispell-args)))
  ;; (add-hook 'text-mode-hook 'text-mode-hook-setup)
  ;; (add-hook 'text-mode-hook 'flyspell-mode)

  ;; enable flyspell check on comments and strings in progmamming modes
  ;; (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  ;; I don't use the default mappings
  (with-eval-after-load 'flyspell
    (define-key flyspell-mode-map (kbd "C-;") nil)
    (define-key flyspell-mode-map (kbd "C-,") nil)
    (define-key flyspell-mode-map (kbd "C-.") nil))
#+END_SRC

Make flyspell enabled for org-mode, see [[http://emacs.stackexchange.com/questions/9333/how-does-one-use-flyspell-in-org-buffers-without-flyspell-triggering-on-tangled][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  ;; NO spell check for embedded snippets
  (defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
    (let ((rlt ad-return-value)
          (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\)")
          (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\)")
          old-flag
          b e)
      (when ad-return-value
        (save-excursion
          (setq old-flag case-fold-search)
          (setq case-fold-search t)
          (setq b (re-search-backward begin-regexp nil t))
          (if b (setq e (re-search-forward end-regexp nil t)))
          (setq case-fold-search old-flag))
        (if (and b e (< (point) e)) (setq rlt nil)))
      (setq ad-return-value rlt)))
#+END_SRC

** Search & Replace / hightlight =M-s=
*** isearch
=C-s=, =C-r=, 
=C-w= add word at point to search string, 
=M-%= query replace
=C-M-y= add character at point to search string
=M-s C-e= add reset of line at point
=C-y= yank from clipboard to search string
=M-n=, =M-p=, history
=C-M-i= complete search string
set the isearch history size, the default is only =16=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (setq history-length 5000)
  (setq regexp-search-ring-max 1000)
  (setq search-ring-max 1000)

  ;; when search a word or a symbol , also add the word into regexp-search-ring
  (defadvice isearch-update-ring (after sd/isearch-update-ring (string &optional regexp) activate)
    "Add search-ring to regexp-search-ring"
    (unless regexp
      (add-to-history 'regexp-search-ring string regexp-search-ring-max)))
#+END_SRC

*** =M-s= prefix
use the prefix =M-s= for searching in buffers
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/make-keymap (key bindings)
    (setq keymap (make-sparse-keymap))
    (dolist (binding bindings)
      (define-key keymap (car binding) (cdr binding)))
    (global-set-key key keymap))

  ;; (sd/make-keymap "\M-s"
  ;;                 '(("w" . save-buffer)
  ;;                   ;; ("\M-w" . save-buffer)
  ;;                   ("e" . revert-buffer)
  ;;                   ("s" . isearch-forward-regexp)
  ;;                   ("\M-s" . isearch-forward-regexp)
  ;;                   ("r" . isearch-backward-regexp)
  ;;                   ("." . isearch-forward-symbol-at-point)
  ;;                   ("o" . occur)
  ;;                   ;; ("h" . highlight-symbol-at-point)
  ;;                   ("h" . highlight-symbol)
  ;;                   ("m" . highlight-regexp)
  ;;                   ("l" . highlight-lines-matching-regexp)
  ;;                   ("M" . unhighlight-regexp)
  ;;                   ("f" . keyboard-quit)
  ;;                   ("q" . keyboard-quit)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package highlight-symbol
    :ensure t)

  (defhydra sd/search-replace (:color red :columns nil)
    "Search"
    ("w" save-buffer "save" :exit t)
    ("e" revert-buffer "revert" :exit t)
    ("u" undo-tree-visualize "undo" :exit t)
    ("s" isearch-forward-regexp "s-search" :exit t)
    ("M-s" isearch-forward-regexp "s-search" :exit t)
    ("r" isearch-backward-regexp "r-search" :exit t)
    ("." isearch-forward-symbol-at-point "search point" :exit t)
    ("/" swiper "swiper" :exit t)
    ("o" occur "occur" :exit t)
    ("h" highlight-symbol "higlight" :exit t)
    ("l" highlight-lines-matching-regexp "higlight line" :exit t)
    ("m" highlight-regexp "higlight" :exit t)
    ("M" unhighlight-regexp "unhiglight" :exit t)
    ("q" nil "quit")
    ("f" nil))

  (global-unset-key (kbd "M-s"))
  (global-set-key (kbd "M-s") 'sd/search-replace/body)


  ;; search and replace and highlight
  (define-key isearch-mode-map (kbd "M-s") 'isearch-repeat-forward)
  (define-key isearch-mode-map (kbd "M-r") 'isearch-repeat-backward)
  (global-set-key (kbd "s-[") 'highlight-symbol-next)
  (global-set-key (kbd "s-]") 'highlight-symbol-prev)
  (global-set-key (kbd "s-\\") 'highlight-symbol-query-replace)
#+END_SRC

*** Occur
Occur search key bindings
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/occur-keys ()
    "My key bindings in occur-mode"
    (interactive)
    (switch-to-buffer-other-window "*Occur*")
    (define-key occur-mode-map (kbd "C-o") nil)
    (define-key occur-mode-map (kbd "C-n") (lambda ()
                                             (interactive)
                                             (occur-next)
                                             (occur-mode-goto-occurrence-other-window)
                                             (recenter)
                                             (other-window 1)))
    (define-key occur-mode-map (kbd "C-p") (lambda ()
                                             (interactive)
                                             (occur-prev)
                                             (occur-mode-goto-occurrence-other-window)
                                             (recenter)
                                             (other-window 1))))

  (add-hook 'occur-hook #'sd/occur-keys)

  (use-package color-moccur
    :ensure t
    :commands (isearch-moccur isearch-all)
    :init
    (setq isearch-lazy-highlight t)
    :config
    (use-package moccur-edit))
#+END_SRC

*** Swiper
stolen from [[https://github.com/mariolong/emacs.d/blob/f6a061594ef1b5d1f4750e9dad9dc97d6e122840/emacs-init.org][here]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package swiper
    :ensure t
    :init
    (setq ivy-use-virtual-buffers t)
    (set-face-attribute 'ivy-current-match nil :background "Orange" :foreground "black")
    :config
    (ivy-mode)
    (global-set-key (kbd "s-/") 'swiper)
    (define-key swiper-map (kbd "M-r") 'swiper-query-replace)
    (define-key swiper-map (kbd "C-.") (lambda ()
                                         (interactive)
                                         (insert (format "%s" (with-ivy-window (thing-at-point 'word))))))
    (define-key swiper-map (kbd "M-.") (lambda ()
                                         (interactive)
                                         (insert (format "%s" (with-ivy-window (thing-at-point 'symbol)))))))
#+END_SRC

** Expand region map
*** Install =expand-region=
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (use-package expand-region
    :ensure t
    :config
    ;; (global-set-key (kbd "C-=") 'er/expand-region)
    )
#+END_SRC

*** Add a =hydra= map for =expand-region= operations
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/mark-line ()
    "Mark current line without whitespace beginning"
    (interactive)
    (back-to-indentation)
    (set-mark (line-end-position)))

  (defhydra sd/expand-selected (:color red :columns nil
                                       :post (deactivate-mark)
                                       )
    "Selected"
    ;; select
    ;; ("e"  er/expand-region "+")
    ("SPC" er/expand-region "+")
    ;; ("c"  er/contract-region "-")
    ("S-SPC" er/contract-region "-")
    ("r" (lambda ()
           (interactive)
           (er/contract-region 0))
     "reset")

    ("i'" er/mark-inside-quotes "in")
    ("i\"" er/mark-inside-quotes nil)
    ("o'" er/mark-outside-quotes "out")
    ("o\"" er/mark-outside-quotes nil)

    ("i{" er/mark-inside-pairs nil)
    ("i(" er/mark-inside-pairs nil)
    ("o{" er/mark-inside-pairs nil)
    ("o(" er/mark-inside-pairs nil)

    ("p" er/mark-paragraph "paragraph")

    ("l" sd/mark-line "line")
    ("u" er/mark-url "url")
    ("f" er/mark-defun "fun")
    ("n" er/mark-next-accessor "next")

    ("x" exchange-point-and-mark "exchange")

    ;; Search
    ;; higlight

    ;; exit
    ("d" kill-region "delete" :exit t)

    ("y" kill-ring-save "yank" :exit t)
    ("M-SPC" nil "quit" :exit t)
    ;; ("C-SPC" "quit" :exit t)
    ("q" deactivate-mark "quit" :exit t))

  (global-set-key (kbd "M-SPC") (lambda ()
                                  (interactive)
                                  (set-mark-command nil)
                                  ;; (er/expand-region 1)
                                  (er/mark-word)
                                  (sd/expand-selected/body)))
#+END_SRC

*** TODO make expand-region hydra work with lispy selected
** =C-w= delete backward word
Refer [[https://github.com/fnwiya/dotfiles/blob/c9ca79f1b22c919d9f4c3a0f944ba8281255a594/setup/.emacs.d/loader-init/_90-kill-region-or-backward-kill-word.el][kill-region-or-backward-kill-word]]
#+BEGIN_SRC emacs-lisp :tangle yes :results silent
  (defun sd/kill-region-or-backward-kill-word ()
    (interactive)
    (if (region-active-p)
        (kill-region (point) (mark))
      (backward-kill-word 1)))

  (global-set-key (kbd "C-w") 'sd/kill-region-or-backward-kill-word)
#+END_SRC

* key
- passion
- vision
- mission

* TODO todolist
** rucket
** player video on iphone for 
** SICP
** music searcher
search music on some music web site
